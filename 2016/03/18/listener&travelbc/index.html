<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>listener&amp;travelbc | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#序这段时间由于做旅行机票的项目，其中涉及到Travelbc系统的定制，对travelbc进行了一点点很小的改动。所谓Travelbc（travel book center）指是航旅度假业务中预约订单数据处理后台中心。这样的改动也给我了一次了解TravelBc代码的机会，给我感触最大的是核心框架的搭建有很特别优秀的设计。为什么我接触的系统设计都那么好？一是因为架构确实好，二是因为我的有很多值得我学">
<meta property="og:type" content="article">
<meta property="og:title" content="listener&travelbc">
<meta property="og:url" content="http://yoursite.com/2016/03/18/listener&travelbc/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#序这段时间由于做旅行机票的项目，其中涉及到Travelbc系统的定制，对travelbc进行了一点点很小的改动。所谓Travelbc（travel book center）指是航旅度假业务中预约订单数据处理后台中心。这样的改动也给我了一次了解TravelBc代码的机会，给我感触最大的是核心框架的搭建有很特别优秀的设计。为什么我接触的系统设计都那么好？一是因为架构确实好，二是因为我的有很多值得我学">
<meta property="og:image" content="http://img1.tbcdn.cn/L1/461/1/910db606b7d0235343d3e9bc199500e0bfad39e6.png">
<meta property="og:image" content="http://img1.tbcdn.cn/L1/461/1/38ffb8e599a359cbd9298dbffd5bdff443167b6a.png">
<meta property="og:image" content="http://img4.tbcdn.cn/L1/461/1/64c33db3948f2684f19bc92b067cb374dee8de87.png">
<meta property="og:image" content="http://img2.tbcdn.cn/L1/461/1/11bb8785681aaf33dd2282674e66ef6c7c5b1056.png">
<meta property="og:updated_time" content="2016-03-18T14:12:48.586Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="listener&travelbc">
<meta name="twitter:description" content="#序这段时间由于做旅行机票的项目，其中涉及到Travelbc系统的定制，对travelbc进行了一点点很小的改动。所谓Travelbc（travel book center）指是航旅度假业务中预约订单数据处理后台中心。这样的改动也给我了一次了解TravelBc代码的机会，给我感触最大的是核心框架的搭建有很特别优秀的设计。为什么我接触的系统设计都那么好？一是因为架构确实好，二是因为我的有很多值得我学">
<meta name="twitter:image" content="http://img1.tbcdn.cn/L1/461/1/910db606b7d0235343d3e9bc199500e0bfad39e6.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-listener&amp;travelbc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/listener&travelbc/" class="article-date">
  <time datetime="2016-03-18T07:50:30.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      listener&amp;travelbc
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#序<br>这段时间由于做旅行机票的项目，其中涉及到Travelbc系统的定制，对travelbc进行了一点点很小的改动。所谓Travelbc（travel book center）指是航旅度假业务中预约订单数据处理后台中心。这样的改动也给我了一次了解TravelBc代码的机会，给我感触最大的是核心框架的搭建有很特别优秀的设计。为什么我接触的系统设计都那么好？一是因为架构确实好，二是因为我的有很多值得我学习的地点。代码拉到类的注释部分发现，写这些代码作者不是别人正是坐在我工位旁边的XX同学，默默的转脸过去看到他那俊朗的侧脸，钦佩之情油然而生。。。。吧啦吧啦吧啦。。。。。<br>话说回来，一个系统能够稳定的运行有很多因素影响，因素之一就是良好的代码设计。曾经有和一个同事探讨什么样的代码才叫好的代码。或者说好的代码应用具有什么样的特点。我当时这样回答的：</p>
<ol>
<li><strong>尽量少的重复代码。</strong></li>
<li><strong>清晰的注释与命名。</strong></li>
<li><strong>每个类最好体现单一职能原则。</strong></li>
<li><strong>良好的继承体系与实现方案。</strong></li>
</ol>
<p>这样的回答必然没有错，关键是好何做到这一点。当然处于菜鸟的我，实在也不知道具体的方案，所以我才写下这篇文章来记录我的学习收获。<br>有时我们会发现一个系统里的代码设计总结会有很多设计模式的影子。而且很有可能最核心的架构设计与通信机制只有到了一种主要的设计模式。如接下来说的这个Travelbc。当然Travelbc的优秀之处包含但不限于这些。。。。。吧啦吧啦吧啦。。。。。</p>
<p>#Observer<br>适用于那些状态与数据需要满足迁一发而动全身的需求，即定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。<br>首先这个里说到几个关键词：</p>
<ol>
<li><strong>一对多</strong>：如何表达这种依赖关系。一个目标可以受多个观察者监控，一个观察者可以监控多个目标。</li>
<li><strong>通知</strong>：如何通知。</li>
<li><strong>自动更新</strong>：调用父类方法更新，无需关心子类类型。</li>
</ol>
<p>##举个栗子<br><img src="http://img1.tbcdn.cn/L1/461/1/910db606b7d0235343d3e9bc199500e0bfad39e6.png" alt=""></p>
<p>这是一个非常适合用于观察者模式学习的现实例子。许多系统在处理应用数据与界面显示时都会进行前端与后端的解藕。用于描述界面的类和用于定义数据的类都可以进行独自的复用。当然他们也可以一起工作。一个表格对象和一个柱状图对象本质上是使用不同表示形式描述同一个应用数据的信息。因为表格对象和柱状图对象互相并不知道对方的存在，所以也就大大的提高了每种界面显示的类的可重用性。当用户改变表格中的信息时，柱状图能立即反映这一变化，当然反过来也是如此。<br>这里也说明了，当数据对象发生改变时，就应该立即通知依赖于这个数据对象的显示类。当然数据对象不应该限制界面显示类的数量，也不应该知道有哪些显示类在依赖于这个数据对象。</p>
<p>Observer模式描述了如何建立这种关系经，这一模式中的关键对象是目标（subject）和观察者（observer）.subject指的就是本例中的数据对象。而observer就是指的是负责显示的类。</p>
<p>这种交互也称为发布-订阅（publish-subscribe）。目标是通知的发布者，它发出通知时并不需知道谁是它的观察者。可以有任意数目的观察者订阅并接受通知。</p>
<p>很多系统中也全使用一种叫做事件驱动模型的架构。这个架构与观察者也有很多关联，<a href="http://blog.csdn.net/zuoxiaolong8810/article/details/9081079" target="_blank" rel="external">传送门</a></p>
<p>##结构与角色</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/38ffb8e599a359cbd9298dbffd5bdff443167b6a.png" alt=""></p>
<p><strong>Subject(目标)</strong></p>
<ul>
<li>目标要拥有观察者的数组。可以有任意多个观察者观察同一个目标。</li>
<li>提供注册和删除观察者对象的接口</li>
</ul>
<p><strong>Observer(观察者)</strong></p>
<ul>
<li>为那些在目标发生改变时需获得通知的对象定义一个更新接口</li>
</ul>
<p><strong>ConcreteSubject(具体目标)</strong></p>
<ul>
<li>将有关状态存入各ConcreteObserver对象。</li>
<li>当它的状态发生改变时，向它的各个观察者发出通知。</li>
</ul>
<p><strong>ConcreteObserver(具体观察者)</strong></p>
<ul>
<li>实现Observer的更新接口实现，当目标发生变化时使状态与目标状态操持一致。</li>
</ul>
<p>##实现机制</p>
<h3 id="目标与观察者之间的映射"><a href="#目标与观察者之间的映射" class="headerlink" title="目标与观察者之间的映射"></a>目标与观察者之间的映射</h3><p>一个目标对象跟踪它应通知的观察者的最简单的方法是显式地在目标中保存观察者的引用。然而，当目标很多而观察者较少时，这样存储可能代价太高。一个解决办法是用时间换空间，用一个关联查找机制（如hash表）来维护目标到观察者的映射，但另一方面，这一方法增加了访问观察者的开销。</p>
<h3 id="观察多个目标"><a href="#观察多个目标" class="headerlink" title="观察多个目标"></a>观察多个目标</h3><p>当一个观察者依赖多个目标时而且需要针对不同的目标做不同的更新操作时，如一个表格对象的每一列的数据显示依赖于不同的数据源时，在这种情况下，必须扩展update接口以使观察者知道是哪一个目标送来的通知，从而作相应的改变。目标对象可以简单地将自己作为update操作的一个参数，让观察者知道就去检查哪一个目标。</p>
<h3 id="是谁触发更新"><a href="#是谁触发更新" class="headerlink" title="是谁触发更新"></a>是谁触发更新</h3><ul>
<li>由目标对象的状态设定操作在改变目标对象的状态后自动调用Notify.这种方法的优点是客户不需要记住要在目标对象上调用Notify,缺点是多个连续的操作会产生多次连接的更新，可能效率较底。</li>
<li>让客户负责在适当的时候调用Notify.这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新，避免了不必要的中间更新。缺点是给客户端增加了触发更新的责任，由于客户可能会忘记调用Nofity，这种方式较易出错。</li>
</ul>
<h3 id="在发出通知前确保目标的状态自身是一致的"><a href="#在发出通知前确保目标的状态自身是一致的" class="headerlink" title="在发出通知前确保目标的状态自身是一致的"></a>在发出通知前确保目标的状态自身是一致的</h3><p>原因是观察者在更新其状态的过程中需要查询目标的当前状态。<br>当Subject的子类调用继承的该项操作时，很容易无意中违反这条自身一致的准则。例如：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/64c33db3948f2684f19bc92b067cb374dee8de87.png" alt=""></p>
<p>此时抽象的Subject中可以使用模板方法（Template Method）发送通知来使得Notify操作作为模板方法中的最后一个操作。这样当子类重定义了Subject的操作时，还可以保证对象的状态是自身一致的。</p>
<h3 id="推拉模型"><a href="#推拉模型" class="headerlink" title="推拉模型"></a>推拉模型</h3><ul>
<li>推模型</li>
</ul>
<p>目标向观察者发送关于改变的详细信息，而不管它们需要与否。</p>
<ul>
<li>拉模型</li>
</ul>
<p>目标除了最小通知外什么也不送出，而在此之后由观察者显式地向目标底询问细节。</p>
<h3 id="显式的指定感兴趣的改变"><a href="#显式的指定感兴趣的改变" class="headerlink" title="显式的指定感兴趣的改变"></a>显式的指定感兴趣的改变</h3><p>你可以扩展目标的注册接口，让各观察注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时，目标仅通知那些已注册为对该事件感兴趣的观察者。</p>
<pre><code>void Subject attach(Observer observer,String interest)
</code></pre><p>此处interest指定感兴趣的事件。在通知时间，目标将这方面的改变作为update操作的一个参数提供给它的观察者。例如：</p>
<pre><code>void Observer update(Subject subject,String interest)
</code></pre><p>###封装复杂的更新语义<br>当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（ChangeManager）.例如：如果一个操作涉及到对几个相互依赖的目标进行改动，就必须保证仅在所有的目标更改完毕后，才一次性地通知他们的观察者，而不是每个目标都通知观察者。</p>
<p><strong>ChangeManager有三个责任</strong></p>
<ul>
<li>它将一个目标映射到它的观察者并提供一个接口来维护这个映射，这就不需要由目标来维护对其观察者的引用。</li>
<li>根据一个目标的请求，它更新所有依赖于这个目标的观察者。</li>
</ul>
<p>##示例</p>
<p>###Subject </p>
<pre><code>public abstract class Citizen {

List pols;

String help = &quot;normal&quot;;

public void setHelp(String help) {
    this.help = help;
}

public String getHelp() {
    return this.help;
}

abstract void sendMessage(String help);

public void setPolicemen() {
    this.pols = new ArrayList();
}

public void register(Policeman pol) {
    this.pols.add(pol);
}

public void unRegister(Policeman pol) {
    this.pols.remove(pol);
}
}
</code></pre><p>###Observer </p>
<pre><code>public interface Policeman {

void action(Citizen ci);
}
</code></pre><p>###ConcreteSubject </p>
<pre><code>public class HuangPuCitizen extends Citizen {

public HuangPuCitizen(Policeman pol) {
    setPolicemen();
    register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for(int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
}

public class TianHeCitizen extends Citizen {

public TianHeCitizen(Policeman pol) {
    setPolicemen();
    register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for (int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
}
</code></pre><p>###ConcreteObserver </p>
<pre><code>public class HuangPuPoliceman implements Policeman {

public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals(&quot;normal&quot;)) {
        System.out.println(&quot;一切正常, 不用出动&quot;);
    }
    if (help.equals(&quot;unnormal&quot;)) {
        System.out.println(&quot;有犯罪行为, 黄埔警察出动!&quot;);
    }
}
}
public class TianHePoliceman implements Policeman {

public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals(&quot;normal&quot;)) {
        System.out.println(&quot;一切正常, 不用出动&quot;);
    }
    if (help.equals(&quot;unnormal&quot;)) {
        System.out.println(&quot;有犯罪行为, 天河警察出动!&quot;);
    }
}
}
</code></pre><p>###Test </p>
<pre><code>public class Test{

public static void main(String[] args) {
    Policeman thPol = new TianHePoliceman();
    Policeman hpPol = new HuangPuPoliceman();

    Citizen citizen = new HuangPuCitizen(hpPol);
    citizen.sendMessage(&quot;unnormal&quot;);
    citizen.sendMessage(&quot;normal&quot;);

    System.out.println(&quot;===========&quot;);

    citizen = new TianHeCitizen(thPol);
    citizen.sendMessage(&quot;normal&quot;);
    citizen.sendMessage(&quot;unnormal&quot;);
}
}
</code></pre><p>###result </p>
<pre><code>有犯罪行为, 黄埔警察出动!
一切正常, 不用出动
===========
一切正常, 不用出动
有犯罪行为, 天河警察出动!
</code></pre><p>#TravelBc&amp;Observer</p>
<p><strong>连蒙带编，终于写到这，还好我没放弃！！！</strong></p>
<p>##需求</p>
<p>Travelbc相关部分的需求比较简单，当Travelbc接收到支付成功的消息后，会根据具体业务进行预约订单与预约记录的创建，由于预约订单与记录的创建或修改会导致一些诸如定时任务的创建，订单与预约状态的修改，Toc时间设置等等。完全符合Observer模式适用范围，因为Observer模式是实现这此逻辑的不二之选。</p>
<p>##结构</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/11bb8785681aaf33dd2282674e66ef6c7c5b1056.png" alt=""></p>
<p>##流程</p>
<p>整个流程就很清晰了，Subject会接收到支付成功的消息，接着会调用ChangeManager中的相应方法，ChangeManager中通过spring的bean注入方式注入Obersver列表。这些的obersver大多叫作XXXProcessor,ChangeManager就会负责Processor与管理工作与迭代通知操作。</p>
<p>#总结</p>
<p>Travelbc&amp;Observer部分分析的内容比较少，主要是因为Observer的内容介绍的比较多。如果能理解Observer模式应该就很容易理解Travelbc中的这块内容。但事实是我其实也没有深刻理解Observer模式，或者我可能会用他，但我不会扩展或升级他。<br>上面的内容有很多来自于书籍或网上教程，虽然我自己个人理解的内容相对少一点，但是我再次强调我现阶段写文章的目的是：</p>
<p><strong>作为自己学习的笔记与总结</strong></p>
<p><strong>方便大家在网上搜索出来快速了解</strong></p>
<p>仅此而已</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/18/listener&travelbc/" data-id="cilxt62p60004issbag97ekek" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/18/spi翻译/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          spi翻译
        
      </div>
    </a>
  
  
    <a href="/2016/03/18/乔布斯魅力演讲/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">乔布斯魅力演讲</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spi/">spi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感悟/">感悟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/演讲/">演讲</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件设计/">软件设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/spi/" style="font-size: 10px;">spi</a> <a href="/tags/感悟/" style="font-size: 10px;">感悟</a> <a href="/tags/演讲/" style="font-size: 10px;">演讲</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/18/UML类图关系符号/">UML类图关系符号</a>
          </li>
        
          <li>
            <a href="/2016/03/18/spi翻译/">spi翻译</a>
          </li>
        
          <li>
            <a href="/2016/03/18/listener&travelbc/">listener&amp;travelbc</a>
          </li>
        
          <li>
            <a href="/2016/03/18/乔布斯魅力演讲/">乔布斯魅力演讲</a>
          </li>
        
          <li>
            <a href="/2016/03/18/软件设计原则/">软件设计原则</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 欣明果果<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>