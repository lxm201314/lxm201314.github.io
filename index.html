<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="突然发现自己的偶像是灰太狼。。。。。。">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="突然发现自己的偶像是灰太狼。。。。。。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="突然发现自己的偶像是灰太狼。。。。。。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/乔布斯魅力演讲/" itemprop="url">
                  乔布斯魅力演讲
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#序<br>偶然发现一个小视频很有意思，分享一下吧。。。。</p>
<p>#正文</p>
<h2 id="1-Set-the-Theme-开场点明主题-、"><a href="#1-Set-the-Theme-开场点明主题-、" class="headerlink" title="1. Set the Theme(开场点明主题)、"></a>1. Set the Theme(开场点明主题)、</h2><ul>
<li>一旦你确定了演讲主题，整个演讲就要围绕这个主题展开。<h2 id="2-Provide-the-OutLine-列出大纲"><a href="#2-Provide-the-OutLine-列出大纲" class="headerlink" title="2. Provide the OutLine(列出大纲)"></a>2. Provide the OutLine(列出大纲)</h2></li>
<li>Open &amp; Close Each Section with a Clear Transition(明确的告诉观众每个部分何时开始何时结束)</li>
<li>Make it easy for your listeners to follow your story(让观众不会半路跟丢)<h2 id="3-Demonstrate-Enthusiasm-展示热情"><a href="#3-Demonstrate-Enthusiasm-展示热情" class="headerlink" title="3. Demonstrate Enthusiasm(展示热情)"></a>3. Demonstrate Enthusiasm(展示热情)</h2><h2 id="4-Sell-an-Experience-销售体验"><a href="#4-Sell-an-Experience-销售体验" class="headerlink" title="4. Sell an Experience(销售体验)"></a>4. Sell an Experience(销售体验)</h2><h2 id="5-Make-numbers-and-statistics-meaningful-赐于引用数据以意义"><a href="#5-Make-numbers-and-statistics-meaningful-赐于引用数据以意义" class="headerlink" title="5. Make numbers and statistics meaningful(赐于引用数据以意义)"></a>5. Make numbers and statistics meaningful(赐于引用数据以意义)</h2></li>
</ul>
<p>数字本身没有意义，除非放入特殊的语境，要让这些数字有意义，给它们来点“比方”，动手包装下数据吧。</p>
<h2 id="6-Make-it-Visual-可视化"><a href="#6-Make-it-Visual-可视化" class="headerlink" title="6. Make it Visual(可视化)"></a>6. Make it Visual(可视化)</h2><p>大多数演讲者喜欢在幻灯片里塞进大量的数据，文字，图表。而乔布斯用丰富的视觉盛宴替代繁冗的文字图表，通常每个幻灯片也只有一两张图片而已。在合适的时刻展现合适的内容。好的演讲，只列出简明的观点，其他的全是演示。 </p>
<h2 id="7-Give-em-a-show（给观众一个展示）"><a href="#7-Give-em-a-show（给观众一个展示）" class="headerlink" title="7. Give `em a show（给观众一个展示）"></a>7. Give `em a show（给观众一个展示）</h2><h2 id="8-Identify-your-memorable-moment-and-build-up-to-it-找出你难忘的时刻，并打造它"><a href="#8-Identify-your-memorable-moment-and-build-up-to-it-找出你难忘的时刻，并打造它" class="headerlink" title="8. Identify your memorable moment and build up to it (找出你难忘的时刻，并打造它)"></a>8. Identify your memorable moment and build up to it (找出你难忘的时刻，并打造它)</h2><p>你演讲中最难忘的瞬间是什么？定下那一刻，然后使出浑身解数把听众引向那里。</p>
<h2 id="9-Rehearse-Rehearse-Rehearse-彩排，彩排，彩排"><a href="#9-Rehearse-Rehearse-Rehearse-彩排，彩排，彩排" class="headerlink" title="9. Rehearse,Rehearse,Rehearse(彩排，彩排，彩排)"></a>9. Rehearse,Rehearse,Rehearse(彩排，彩排，彩排)</h2><h2 id="10-Give-your-audience-an-added-bonus-to-walk-away-with（给你的听众一个额外的好处来领走）"><a href="#10-Give-your-audience-an-added-bonus-to-walk-away-with（给你的听众一个额外的好处来领走）" class="headerlink" title="10. Give your audience an added bonus to walk away with（给你的听众一个额外的好处来领走）"></a>10. Give your audience an added bonus to walk away with（给你的听众一个额外的好处来领走）</h2><p>#总结<br><a href="http://v.163.com/movie/2013/8/B/A/M955LEP6S_M955M7HBA.html" target="_blank" rel="external">视频地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/spi翻译/" itemprop="url">
                  spi翻译
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#序</p>
<p>我所在的团队为航旅度假技术团队，度假有自己下单系统（travelbuy），最近travelbuy为更友好的支持各垂直业务的下单，引入了spi的机制，到底spi是什么，我也浏览了一些网上的文章，有了一个大致的了解。最简单的spi实现则为jdk的spi支持，下面我也尝试着翻译一篇非常简单的英文资料，虽然这篇资料用词简单，内容也很简单，但对于我一个四级刚及格的同学来说挑战也挺大的，不仅因为英语差，而且我也是第一次翻译。翻译的不好大家多多包涵，非常有可能大家读这篇文章还不如读英语原文顺畅，但也不要打我，我也是想挑战一下自己吧。</p>
<p>#正文</p>
<p>###<a href="http://www.lordofthejars.com/2011/11/en-ti-puedo-ver-la-libertad-tu-me-haces.html" target="_blank" rel="external">原文</a></p>
<p>###<strong>翻译</strong></p>
<p>javadoc中ServiceLoader介绍说：服务通常是一系列接口或类。一个服务提供者则是一个服务的具体实现。</p>
<p>jdk6之后的版本提供了简单的加载Service-provider的基础实现。它是非常简单的，你不需要去理解在复杂系统中为你的应用实现插件的具体实现，在很多场景下你所实现的服务能被其他的模块系统所自动引用。</p>
<p>我真正喜欢Jdk Services的原因是你的服务一定没有依赖任何类。另外你只需要把jar文件放到classpath下就可以注册一个新的服务实现，其他不需要做任何事情。</p>
<p>现在我会解释我们将要实现的服务，然后我会展示如何去编写它。</p>
<p>我们想实现一个根据每一个输入结构化种类（逗号分隔形式，tab分隔形式。。。。）返回一个String[]的系统。例如可以接收输入如：a,b,c,d 或 1<tab>2<tab>3<tab>4,系统将会返回[a,b,c,d]或[1,2,3,4].</tab></tab></tab></p>
<p>所以我们的系统将有三个java项目。</p>
<p>第一个项目定义了服务的协议（一个接口）和一个以互联网媒体类型（如 text/csv）作为输入数据的main类。然后创建一个工厂类，它的作用是询问哪个注册的服务可以将 input 转化成 String[].</p>
<p>其他两个项目分别实现已经定义好的服务。一个服务是转换逗号分隔的输入值，一个服务是转换tab分隔的输入值。</p>
<p>我们来看看代码部分：</p>
<p>主项目（reader）由一个接口，一个主类和一个工厂类组成。</p>
<p>最重要的部分解码接口，也就是定义的服务。</p>
<pre><code>public interface Decode {

 boolean isEncodingNameSupported(String encodingName);
 String[] getContent(String data);

}
</code></pre><p>定义了两个操作，一个是根据服务是否支持输入值类型进行返回，另一个是将输入值转换为String[].</p>
<p>解码工厂类负责返回支持相应编码的服务实现类。事实上这个类包括 java.util.ServiceLoader的调用。ServiceLoader是负责加载注册的服务的。</p>
<pre><code>public class DecodeFactory {

 private static ServiceLoader decodeSetLoader = ServiceLoader.load(Decode.class);

 public static Decode getDecoder(String encodingName) throws UnsupportedEncodingException {

  for (Decode decode : decodeSetLoader) {
   if(decode.isEncodingNameSupported(encodingName)) {
    return decode;
   }
  }

  throw new UnsupportedEncodingException();
 }
}
</code></pre><p>在第三行，我们加载了所有在classpath下注册的服务。在第七行我们迭代的询问第一个服务是不是支持给定的解码。</p>
<p>最后main类为：</p>
<pre><code>public class App {  

 public static void main(String[] args) throws UnsupportedEncodingException {  

  String encodeName = args[0];  
  String data = args[1];  

  Decode decoder = DecodeFactory.getDecoder(encodeName);  
  System.out.println(Arrays.toString(decoder.getContent(data)));  

 }  
} 
</code></pre><p>现在你如果你使用 java -jar reader.jar “text/csv” “a,b,c,d” 来运行这个类，将会抛出一个UnsupportedEncodingException，现在我们就实现我们的第一个服务，注意reader项目将不会被改变或重新编译。</p>
<p>我们将要实现的第一个服务是可以支持以逗号分隔编码的输入值，只有一个类和一个文件是重要的。</p>
<p>csv类是一个解码接口的实现。</p>
<pre><code>public class CSVDecoder implements Decode {  

 private static final String DELIMITER = Character.toString(DecimalFormatSymbols.getInstance().getPatternSeparator());  

 public boolean isEncodingNameSupported(String encodingName) {  
  return &quot;text/csv&quot;.equalsIgnoreCase(encodingName.trim());  
 }  

 public String[] getContent(String data) {  

  List values = new LinkedList();  

  StringTokenizer parser = new StringTokenizer(data, DELIMITER);  

  while(parser.hasMoreTokens()) {  
   values.add(parser.nextToken());  
  }  

  return values.toArray(new String[values.size()]);  

 }  

} 
</code></pre><p>正如你看到一个简单的StringTokenizer类。只需要知道这个类是语言环境敏感的，在那些使用逗号（，）作为数字分隔符，分号（；）作为字符串分隔符的国家。</p>
<p>接下来重要的是被放在META-INF下的文件，这个文件中包括一个指针指向服务的实现类。</p>
<p>这个文件应该被放在META-INF/services下，它的命名为接口的全限定名，在这个例子中是 org.alexsotob.reader.Decode。文件内容为服务实现类的全限定名。</p>
<pre><code>org.alexsotob.reader.csv.CSVDecoder #Comma-separated value decode.
</code></pre><p>现在你可以打包这个工程，重新运行已经加入csv.jar到classpath下的reader工程。现在就可以输出a,b,c,d的数组，而不会再抛出unsupported exception。</p>
<p>现在看来：Reader这个工程并没有被修改，但他的功能已经被改变。现在你可以针对另一个新类型的输入开发一个新的服务实现，唯一需要你注意的就是将他们复制到classpath下。</p>
<p>注意所有的服务应该有一个默认的无参构造方法。</p>
<p>对于那此使用Spring的人来说，Services也被三种不同的FactoryBeans支持：ServiceFactoryBean, ServiceListFactoryBean, ServiceLoaderFactoryBean.</p>
<p>正如我在这个帖子开始时说的，如果你想创建一个简单插件系统，JDK Services 是一个简单的（但功能强大）方案。在我看来JDK Services已经足够了，我从来没有更复杂的需求了。但在有些情况下你想要一个完全的插件实现方案，例如Eclipse插件或甚至是OSGI,你可以使用JPF.</p>
<p>我希望你发现这个帖子有用，你现在知道（或者你可以还是不知道）了一个开发插件和播放模块的简单方案。</p>
<p>###<strong>Code</strong></p>
<p><a href="https://github.com/downloads/maggandalf/Blog-Examples/reader.zip" target="_blank" rel="external">Main Project</a></p>
<p><a href="https://github.com/downloads/maggandalf/Blog-Examples/csvDec.zip" target="_blank" rel="external">Comma-Separated Values Service </a></p>
<p><a href="https://github.com/downloads/maggandalf/Blog-Examples/tsvDec.zip" target="_blank" rel="external">Tab-Separated Values Service </a></p>
<p>#总结<br>废话不多说，直接over了。。。。。再会！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/软件设计原则/" itemprop="url">
                  软件设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#序</p>
<p>上次更新博客已是十四天前，这两个星期的时间，在下也没有懈怠，草草的看了一些软件设计的书，当昨天合上最后一本的时候，突然发现自己心里啥都没记住，难道我已经达到了学习的最高境界，心中无书胜有书，我完全在放屁。两个星期没更新了，箭在弦上，不得不发。虽然只是草草的看一遍或者一部分，但在过程中也作了一些笔记，这篇文章大部分也就是我笔记的内容，比较虚，比较空，等以后我更深入了解后，再做更深入的贡献！</p>
<p>#读了什么书？</p>
<p>人称软件设计三部曲的<strong>《设计模式》《重构》《重构与模式》</strong><br><strong>《设计模式》</strong>：如果一部电影豆瓣评分高达9分，你会不会看？那如果是一本书呢？</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/87a45a8cf691145b1ba11bda92226c7c39a8ae32.png" alt="screenshot"></p>
<p>深深的感受下amazon关于这本书有用度排名第一的评论：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/cc6c34dfc512576d2acb096b60a9f1947589b086.png" alt="screenshot"></p>
<p>什么？没看懂！没关系，我是只拿这个来提高这篇文章的逼格用的，不过放心对于这本书几乎清一色的好评。</p>
<p><strong>《重构》</strong>：豆瓣评分一样高达9.1分，和《设计模式》一样，</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/51b89c69a2ef80cca653d8cac8c596af424e595a.png" alt="screenshot"></p>
<p>有关于这本书的作者，就多说几句：</p>
<p><strong>福勒（Martin Fowler）</strong>，在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。Thought Works是一家从事企业应用开发和集成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《分析模式》、《UML精粹》和《重构》等。</p>
<p><strong>《重构与模式》</strong>：看看为这本书做序的人你就知道这本书为什么值得一看了。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/d48895d731fd19b2017056a4762761abc0758e95.png" alt="screenshot"></p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/d1107a6bef95076df07532cd83a66a8d86007d3e.png" alt="screenshot"></p>
<p><strong>重构是一个动作（小步快跑，持续迭代），模式是一个结果（呈现出合理使用设计模式的架构）</strong></p>
<p>#什么是好书？<br>关于这点我在这两个星期也有点感悟。到底什么是好书!我个人认为：</p>
<p>#####1. 从0到1，提出新的概念，新的思维，新的方案并成为大众所接受的书。</p>
<p>#####2. 对实践经验进行全面深刻的总结，并能帮助大众解决实际问题的书。</p>
<p>#####3. 启发式的书籍，在读的过程中给人一种醍醐灌顶，相见恨晚的感觉，这种书不一定给出具体的解决方案，但会影响读者思考问题的方式。</p>
<p>#关键字</p>
<p>##开闭</p>
<p>说开闭原则是一切软件设计的终极目标一点也不为过，举个例子就是开闭原则就是宪法，而所有的法律法规的制定都要以宪法内容为基准，反过来如果所有法律法规内容和规范都执行的很好，也就达到了宪法的内容规定。所谓开闭原则指的是：对扩展开放，对修改封闭。如何理解开闭原则？</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/1a0284e4e2e6a6148bb09b98fb14a558d27aabcf.png" alt="screenshot"></p>
<p>如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就显得特别僵化，开闭原则建议我们应该对系统进行重构，这样以后对系统再进行那样的改动时，就不会导致更多的修改。如果正确地应用开闭原则，那么以后再进行两样的改动时，就只需要添加新的代码，而不必改动已经正常运行的代码。</p>
<p>开闭原则具有两个主要的特征：</p>
<p><strong>1. 对扩展是开放的</strong><br> 这意味关模块的行为是可以扩展的，当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块的功能。</p>
<p><strong>2. 对于更改是封闭的</strong><br> 对模块行为进行扩展时，不必改动模块的源代码，模块的二进制可执行版本，无论是可链接的库，DLL或者java的.jar文件，都无需改动。</p>
<p>###抽象</p>
<p>如何实现开闭原则，关键是抽象。抽象是我们控制软件复杂性的重要手段。</p>
<p>要想达到对更改是封闭的，我们必须面向抽象编程;</p>
<p>要想达到对扩展是开放的，我们必须抽象变化模块;</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/5d1a7fda5d26d8ea1cd55c9d03e88ca5f78cda0d.png" alt="screenshot"></p>
<p>左边展示了一个简单的不遵循开闭原则的设计。client类和server类都是具体类。client类使用server类，如果我们希望client对象使用另外一个不同的服务器对象，那么就必须要把client类中使用server类的地方 更改为新的服务器类。</p>
<p>右边展示了一个针对上述问题的遵循开闭原则的设计，在这个设计中，clientInterface类是一个拥有抽象成员函数的抽象类。client类使用这个抽象类，然而client类的对象却使用server类的派生类的对象，如果我们希望client对象使用一个不同的服务器类，那么只需要从clientInterface类派生一个新的类，无需对client类做任何改动。这就做到了对扩展开放，对更改封闭。</p>
<p>###依赖倒置</p>
<p>据说所说，任何企业的架构归根结底都是按照某种形式的层次分层设计的。最经典的莫过于三层架构的系统，这这种方式下，在表现层实现用户界面，在领域层实现领域逻辑，在数据源层存取数据，这种方式使你可以将复杂的领域逻辑从界面代码中抽取出来，单独放到中间层，用对象加以建模和组织。</p>
<p>如何将企业应用组织成不同的层次？以及这些层次之间如何协同工作？</p>
<p>我觉得最重要策略或至少一定会用到依赖倒置的原则，这个原则恰恰是面向抽象编程以达到开闭原则的重要一步：</p>
<p>依赖原则简单来说：</p>
<p><strong>1.高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong><br><strong>2.抽象不应该依赖于细节，细节应该依赖于抽象</strong></p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/7926dc37db5999400dfe8c9714bb437e801191d7.png" alt="screenshot"></p>
<p>上图中高层的policy layer使用了低层的mechanis layer，而mechanism layer又使用了更细节的层utility layer，这看起来似乎是正确的，但是policy layer对于其下一直到utility layer的改动都是敏感的，这种依赖关系是传递的。policy layer依赖于某些依赖于utility layer的层次：因此policy layer传递性地依赖于utility layer。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/ed821d9edff2da4270e408ebc39e957428beb99a.png" alt="screenshot"></p>
<p>上图展示了一个更为合适的模型。第一个较高层次都为它所需要的服务声明一个抽象接口，较低的层次实现了这些抽象接口，每个高层类都通过该抽象接口使用下一层，这样高层就不依赖于低层，低层反而依赖于在高层中声明的抽象服务接口。这不仅解除了policy layer对于utility layer的传递依赖关系，甚至也解除了policy layer对于mechanism layer的依赖关系。</p>
<p>##委托</p>
<p>一个好的领导不一定知道一件事具体应该怎么做，但一定知道把什么样的事分委托给什么样的人去办，而且委托过程很简单，可能只是一句话，也可能只是面对一个人，就能把事情委托下去并且能办好。程序也是一样，客户端代码对服务或其他函数的调用方法一定是最简洁最明确的，客户端能一行代码完成功能的，绝不用二行代码，能用二行代码完成的，绝不用三行代码，要达到这样的目标必需要对被调用方进行数据封装，逻辑隔离，变化抽象等等，使用到的设计模式包括创建型模式和结构型模式。</p>
<p>委托型的设计模式包括很多：典型的有：</p>
<p><strong>适配器模式</strong></p>
<p><strong>中介者模式</strong></p>
<p><strong>访问者模式</strong></p>
<p><strong>观察者模式</strong></p>
<p><strong>工厂模式</strong></p>
<p>等等等等。。。。太多了， 在我看来，凡是逻辑不是自己实现还是移交给其他类的模式都可以归纳为这类下。</p>
<p>##封装</p>
<p>面向对象的三大特性：封装，继承，多态：</p>
<p>如果客户端能简单的调用后台或服务的统一接口，那么类与类之间就必须做好数据与方法的封装：</p>
<p>迪米特原则：<br>迪米特原则英文全称为Law of Demeter，简称LOD，也称为最少知识原则（Least Knowledge Principle）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>迪米特法则还有一个英文解释是：Only talk to your immedate friends，翻译过来就是：只与直接的朋友通信。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>
<p>其实涉及到很多的设计模式：</p>
<p><strong>组合模式</strong></p>
<p><strong>解释器模式</strong></p>
<p><strong>策略模式</strong></p>
<p><strong>命令模式</strong></p>
<p><strong>门面模式</strong></p>
<p>等等等等</p>
<p>#总结</p>
<p><strong>防止过度设计</strong></p>
<p><strong>重构一般情况下并不能减少代码量（除了去除重复之外），重构与模式主要目的是使代码易于扩展，易于阅读，结构清晰。</strong></p>
<p><strong>不要吝惜去新写一个类。，任何一个复杂的逻辑分支（if,switch）都可以通过新建一个类，使用相关模式进行重构（解释器模式，组合模式，策略模式，命令模式，工厂模式等等）</strong></p>
<p><strong>软件是人类有史以来最复杂的系统。其一、软件系统本身规模庞大，参与人手众多，难以管理；其二、环境和需求不断变化，且错误难以避免。人类无法驾驭过于复杂的事物，于是只能寻找方法简化软件系统：把系统分为许多子部分，人们开发一个部分的时候，系统其他部分都是一种抽象，无需了解其细节</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/关注技术本身/" itemprop="url">
                  关注技术本身
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天看了一些关于软件设计类的书籍，但是时间短暂，加上自己的代码量基础并不是很多，所以收获的知识很少，但是却给了一个引导性的启发和一个可能长期保持兴趣点。有两方面的感想。<br>1：软件设计一直是我非常感兴趣的领域，我会一直关注这块领域。<br>2：技术人员应该有自己的技术追求。<br>关于第二点我想多说一些：<br>完成业务功能业务之外，我们作为技术开发人员更应该关注技术本身的美，如何创造和完善这种美，是我们技术人员不断的追求，如果一直在追求需求，需求，功能，功能，那不是技术人员。搞技术的越来越懂业务，搞业务的依然不搞技术，我想这不是一个好的发展趋势，技术人员应该有技术人员自己的追求。只感觉到大家工作的目的都在为生活或者生存下去，这点不可否认，但是在为生存打拼的时候，我们是否应该有更高的技术追求，把一块业务写好，把一段程序写得完美。这才是一个作为技术人员应该的做的事，而不是只为了完成需求或功能而在写程序，把写程序当作一个生存技能，而不是当作兴趣爱好来做，那个势必会每天感觉很累。面对每天大量的工作量，可能我们渐渐的麻木起来，也很少有时间去思考技术的本质，渐渐的忘却或者根本就没有理解“用技术改变世界”的伟大志向。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/UML类图关系符号/" itemprop="url">
                  UML类图关系符号
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#序<br><strong>UML</strong>（Unified Modeling Language）统一建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 <strong>balabala</strong>。。。。。。一大堆</p>
<p>平常我们在学习设计模式或者学习某个系统的架构时，大多都会接触到UML图，我个人最常看到的就是类图，序列图。</p>
<p>由经常接触，很多UML的符号不是在了解，导致很多图看不太明白。所以就是从网上搜集一些资料作下记录以便及时查看。</p>
<p><strong>本文主要是讲述类图中类与类之间的关系的描述符号</strong></p>
<p>#正文</p>
<p>##综述<br><strong>类图（Class Diagram）</strong>是显示了模型的静态结构，特别是模型中存在的类，类的内部结构以及它们与其他类的关系等。</p>
<p>UML中描述对象和类之间相互关系的方式包括：</p>
<ol>
<li><strong>依赖（Dependency）</strong>，</li>
<li><strong>关联（Association）</strong>，</li>
<li><strong>聚合（Aggregation）</strong>，</li>
<li><strong>组合（Composition）</strong>，</li>
<li><strong>泛化（Generalization）</strong>，</li>
<li><strong>实现（Realization）</strong></li>
</ol>
<p>##依赖（Dependency）虚线箭头表示</p>
<p>元素A的变化会影响元素B,但反之不成立，那么B和A的关系是依赖关系，B依赖A;</p>
<ol>
<li>依赖关系也是类与类之间的联结</li>
<li>依赖总是单向的。（#add 注意，要避免双向依赖。一般来说，不应该存在双向依赖。）</li>
<li><p>依赖关系在 Java 或 C++ 语言中体现为<strong>局部变量、方法的参数或者对静态方法的调用</strong>。</p>
<p> class Person<br> {<br> void buy(Car car){<br> }<br> }</p>
</li>
</ol>
<p><img src="http://img3.tbcdn.cn/L1/461/1/2dd95525d419105570047b69cca75996258c5cbe.png" alt=""></p>
<p>表示方法：<strong>虚线加箭头</strong></p>
<p>特点：当类与类之间有使用关系时就属于依赖关系，不同于关联关系，依赖不具有“拥有关系”，而是一种<strong>“相识关系”</strong>，只在某个<strong>特定地方（比如某个方法体内）才有关系</strong>。</p>
<p>##关联（Association）实线箭头表示<br>元素间的结构化关系，是一种弱关系，被关联的元素间通常可以被独立的考虑。uml中用实线表示Association关系，箭头指向被依赖元素</p>
<ol>
<li><p>关联关系是类与类之间的联结，它使一个类知道另一个类的属性和方法。<br>2、关联可以是双向的，也可以是单向的（#add还有自身关联）。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>3、在 Java 或 c++ 中，关联关系是通过<strong>使用成员变量来实现的</strong>。</p>
<p> class 徒弟<br> {<br> };<br> class 唐僧<br>  {</p>
<pre><code>protected: list&lt;徒弟&gt; tdlist;
</code></pre><p> };</p>
</li>
</ol>
<p><img src="http://img2.tbcdn.cn/L1/461/1/7280ecb9c4cdcea531557b5b213d34a47f66378e.png" alt=""></p>
<p>表示方法：<strong>实线箭头</strong></p>
<p>特征：表示类与类或类与接口之间的依赖关系，表现为“<strong>拥有关系</strong>”；具体到代码可以<strong>用实例变量来表示</strong>。</p>
<p>##聚合（Aggregation）：带空心菱形头表示</p>
<p>关联关系的一种特例，表示部分和整体（整体 has a 部分）的关系。uml中用带空心菱形头的实线表示Aggregation关系，菱形头指向整体。</p>
<ol>
<li>聚合关系是关联关系的一种，是强的关联关系。</li>
<li>聚合是<strong>整体和部分</strong>之间的关系，例如汽车由引擎、轮胎以及其它零件组成。</li>
<li>聚合关系也是<strong>通过成员变量来实现</strong>的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，<strong>一个代表整体，一个代表部分</strong>。</li>
<li>关联与聚合仅仅从 Java 或 C++ 语法上是无法分辨的，必须考察所涉及的类之间的逻辑关系。</li>
</ol>
<pre><code>class 引擎
 {
 };
 class 轮胎
 {
 };
 class 汽车
 {
        protected:引擎 engine;
        protected:轮胎 tyre[4];
 };
</code></pre><p><img src="http://img1.tbcdn.cn/L1/461/1/bf5c918b6456fa1f9d8d7b5087663fc80f00eeaf.png" alt="">\</p>
<p>表示方法：<strong>空心菱形实线箭头头</strong></p>
<p>特征：属于是关联的特殊情况，<strong>体现部分-整体关系</strong>，是一种弱拥有关系；整体和部分可以<strong>有不一样的生命周期</strong>；是一种弱关联；</p>
<p>##组合（Composition）：带实心菱形头的实线表示</p>
<p>组合是聚合关系的变种，表示元素间更强的组合关系。如果是组合关系，如果整体被破坏则个体一定会被破坏，而聚合的个体则可能是被多个整体所共享的，不一定会随着某个整体的破坏而被破坏。uml中用带实心菱形头的实线表示Composition关系，菱形头指向整体。</p>
<ol>
<li>合成关系是关联关系的一种，是比聚合关系还要强的关系。</li>
<li><p>它要求普通的聚合关系中<strong>代表整体的对象负责代表部分的对象的生命周期</strong>。</p>
<p> class 肢<br>  {<br>  };<br>  class 人<br>  {</p>
<pre><code>protected:  肢   limb[4];
</code></pre><p>  };</p>
</li>
</ol>
<p><img src="http://img1.tbcdn.cn/L1/461/1/8ac79a0f5923e13c017ff459646ae1bc886f5959.png" alt=""></p>
<p>表示方法:<strong>实心菱形加实线箭头</strong><br>特征：属于是关联的特殊情况，也体现了体现部分-整体关系，是一种强“拥有关系”；<strong>整体与部分有相同的生命周期</strong>，是一种强关联；</p>
<p>##泛化（Generalization）带空心箭头的实线</p>
<p>泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字来直接表示这种关系。</p>
<p>泛化关系表示类与类之间的继承关系，接口与接口之间的继承关系。</p>
<pre><code>public abstract class Employee{
}
public class Professor extends Employee{
}
</code></pre><p><img src="http://img2.tbcdn.cn/L1/461/1/455e1ada7610d6f4584670011ee887a80511dd3d.png" alt=""></p>
<p>##实现 (Realization）：空心箭头和虚线表示</p>
<p>对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。</p>
<pre><code>public interface CollegePerson{
}
public class Professor implements CollectPersion{
}
</code></pre><p><img src="http://img1.tbcdn.cn/L1/461/1/138e748fa0a3fe43d1a747a4cb68b6bf505bb614.png" alt=""></p>
<p>#总结</p>
<p>没什么好总结的，多用多查，记得就行。。。。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/listener&travelbc/" itemprop="url">
                  listener&travelbc
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T15:50:30+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#序<br>这段时间由于做旅行机票的项目，其中涉及到Travelbc系统的定制，对travelbc进行了一点点很小的改动。所谓Travelbc（travel book center）指是航旅度假业务中预约订单数据处理后台中心。这样的改动也给我了一次了解TravelBc代码的机会，给我感触最大的是核心框架的搭建有很特别优秀的设计。为什么我接触的系统设计都那么好？一是因为架构确实好，二是因为我的有很多值得我学习的地点。代码拉到类的注释部分发现，写这些代码作者不是别人正是坐在我工位旁边的XX同学，默默的转脸过去看到他那俊朗的侧脸，钦佩之情油然而生。。。。吧啦吧啦吧啦。。。。。<br>话说回来，一个系统能够稳定的运行有很多因素影响，因素之一就是良好的代码设计。曾经有和一个同事探讨什么样的代码才叫好的代码。或者说好的代码应用具有什么样的特点。我当时这样回答的：</p>
<ol>
<li><strong>尽量少的重复代码。</strong></li>
<li><strong>清晰的注释与命名。</strong></li>
<li><strong>每个类最好体现单一职能原则。</strong></li>
<li><strong>良好的继承体系与实现方案。</strong></li>
</ol>
<p>这样的回答必然没有错，关键是好何做到这一点。当然处于菜鸟的我，实在也不知道具体的方案，所以我才写下这篇文章来记录我的学习收获。<br>有时我们会发现一个系统里的代码设计总结会有很多设计模式的影子。而且很有可能最核心的架构设计与通信机制只有到了一种主要的设计模式。如接下来说的这个Travelbc。当然Travelbc的优秀之处包含但不限于这些。。。。。吧啦吧啦吧啦。。。。。</p>
<p>#Observer<br>适用于那些状态与数据需要满足迁一发而动全身的需求，即定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。<br>首先这个里说到几个关键词：</p>
<ol>
<li><strong>一对多</strong>：如何表达这种依赖关系。一个目标可以受多个观察者监控，一个观察者可以监控多个目标。</li>
<li><strong>通知</strong>：如何通知。</li>
<li><strong>自动更新</strong>：调用父类方法更新，无需关心子类类型。</li>
</ol>
<p>##举个栗子<br><img src="http://img1.tbcdn.cn/L1/461/1/910db606b7d0235343d3e9bc199500e0bfad39e6.png" alt=""></p>
<p>这是一个非常适合用于观察者模式学习的现实例子。许多系统在处理应用数据与界面显示时都会进行前端与后端的解藕。用于描述界面的类和用于定义数据的类都可以进行独自的复用。当然他们也可以一起工作。一个表格对象和一个柱状图对象本质上是使用不同表示形式描述同一个应用数据的信息。因为表格对象和柱状图对象互相并不知道对方的存在，所以也就大大的提高了每种界面显示的类的可重用性。当用户改变表格中的信息时，柱状图能立即反映这一变化，当然反过来也是如此。<br>这里也说明了，当数据对象发生改变时，就应该立即通知依赖于这个数据对象的显示类。当然数据对象不应该限制界面显示类的数量，也不应该知道有哪些显示类在依赖于这个数据对象。</p>
<p>Observer模式描述了如何建立这种关系经，这一模式中的关键对象是目标（subject）和观察者（observer）.subject指的就是本例中的数据对象。而observer就是指的是负责显示的类。</p>
<p>这种交互也称为发布-订阅（publish-subscribe）。目标是通知的发布者，它发出通知时并不需知道谁是它的观察者。可以有任意数目的观察者订阅并接受通知。</p>
<p>很多系统中也全使用一种叫做事件驱动模型的架构。这个架构与观察者也有很多关联，<a href="http://blog.csdn.net/zuoxiaolong8810/article/details/9081079" target="_blank" rel="external">传送门</a></p>
<p>##结构与角色</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/38ffb8e599a359cbd9298dbffd5bdff443167b6a.png" alt=""></p>
<p><strong>Subject(目标)</strong></p>
<ul>
<li>目标要拥有观察者的数组。可以有任意多个观察者观察同一个目标。</li>
<li>提供注册和删除观察者对象的接口</li>
</ul>
<p><strong>Observer(观察者)</strong></p>
<ul>
<li>为那些在目标发生改变时需获得通知的对象定义一个更新接口</li>
</ul>
<p><strong>ConcreteSubject(具体目标)</strong></p>
<ul>
<li>将有关状态存入各ConcreteObserver对象。</li>
<li>当它的状态发生改变时，向它的各个观察者发出通知。</li>
</ul>
<p><strong>ConcreteObserver(具体观察者)</strong></p>
<ul>
<li>实现Observer的更新接口实现，当目标发生变化时使状态与目标状态操持一致。</li>
</ul>
<p>##实现机制</p>
<h3 id="目标与观察者之间的映射"><a href="#目标与观察者之间的映射" class="headerlink" title="目标与观察者之间的映射"></a>目标与观察者之间的映射</h3><p>一个目标对象跟踪它应通知的观察者的最简单的方法是显式地在目标中保存观察者的引用。然而，当目标很多而观察者较少时，这样存储可能代价太高。一个解决办法是用时间换空间，用一个关联查找机制（如hash表）来维护目标到观察者的映射，但另一方面，这一方法增加了访问观察者的开销。</p>
<h3 id="观察多个目标"><a href="#观察多个目标" class="headerlink" title="观察多个目标"></a>观察多个目标</h3><p>当一个观察者依赖多个目标时而且需要针对不同的目标做不同的更新操作时，如一个表格对象的每一列的数据显示依赖于不同的数据源时，在这种情况下，必须扩展update接口以使观察者知道是哪一个目标送来的通知，从而作相应的改变。目标对象可以简单地将自己作为update操作的一个参数，让观察者知道就去检查哪一个目标。</p>
<h3 id="是谁触发更新"><a href="#是谁触发更新" class="headerlink" title="是谁触发更新"></a>是谁触发更新</h3><ul>
<li>由目标对象的状态设定操作在改变目标对象的状态后自动调用Notify.这种方法的优点是客户不需要记住要在目标对象上调用Notify,缺点是多个连续的操作会产生多次连接的更新，可能效率较底。</li>
<li>让客户负责在适当的时候调用Notify.这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新，避免了不必要的中间更新。缺点是给客户端增加了触发更新的责任，由于客户可能会忘记调用Nofity，这种方式较易出错。</li>
</ul>
<h3 id="在发出通知前确保目标的状态自身是一致的"><a href="#在发出通知前确保目标的状态自身是一致的" class="headerlink" title="在发出通知前确保目标的状态自身是一致的"></a>在发出通知前确保目标的状态自身是一致的</h3><p>原因是观察者在更新其状态的过程中需要查询目标的当前状态。<br>当Subject的子类调用继承的该项操作时，很容易无意中违反这条自身一致的准则。例如：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/64c33db3948f2684f19bc92b067cb374dee8de87.png" alt=""></p>
<p>此时抽象的Subject中可以使用模板方法（Template Method）发送通知来使得Notify操作作为模板方法中的最后一个操作。这样当子类重定义了Subject的操作时，还可以保证对象的状态是自身一致的。</p>
<h3 id="推拉模型"><a href="#推拉模型" class="headerlink" title="推拉模型"></a>推拉模型</h3><ul>
<li>推模型</li>
</ul>
<p>目标向观察者发送关于改变的详细信息，而不管它们需要与否。</p>
<ul>
<li>拉模型</li>
</ul>
<p>目标除了最小通知外什么也不送出，而在此之后由观察者显式地向目标底询问细节。</p>
<h3 id="显式的指定感兴趣的改变"><a href="#显式的指定感兴趣的改变" class="headerlink" title="显式的指定感兴趣的改变"></a>显式的指定感兴趣的改变</h3><p>你可以扩展目标的注册接口，让各观察注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时，目标仅通知那些已注册为对该事件感兴趣的观察者。</p>
<pre><code>void Subject attach(Observer observer,String interest)
</code></pre><p>此处interest指定感兴趣的事件。在通知时间，目标将这方面的改变作为update操作的一个参数提供给它的观察者。例如：</p>
<pre><code>void Observer update(Subject subject,String interest)
</code></pre><p>###封装复杂的更新语义<br>当目标和观察者间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（ChangeManager）.例如：如果一个操作涉及到对几个相互依赖的目标进行改动，就必须保证仅在所有的目标更改完毕后，才一次性地通知他们的观察者，而不是每个目标都通知观察者。</p>
<p><strong>ChangeManager有三个责任</strong></p>
<ul>
<li>它将一个目标映射到它的观察者并提供一个接口来维护这个映射，这就不需要由目标来维护对其观察者的引用。</li>
<li>根据一个目标的请求，它更新所有依赖于这个目标的观察者。</li>
</ul>
<p>##示例</p>
<p>###Subject </p>
<pre><code>public abstract class Citizen {

List pols;

String help = &quot;normal&quot;;

public void setHelp(String help) {
    this.help = help;
}

public String getHelp() {
    return this.help;
}

abstract void sendMessage(String help);

public void setPolicemen() {
    this.pols = new ArrayList();
}

public void register(Policeman pol) {
    this.pols.add(pol);
}

public void unRegister(Policeman pol) {
    this.pols.remove(pol);
}
}
</code></pre><p>###Observer </p>
<pre><code>public interface Policeman {

void action(Citizen ci);
}
</code></pre><p>###ConcreteSubject </p>
<pre><code>public class HuangPuCitizen extends Citizen {

public HuangPuCitizen(Policeman pol) {
    setPolicemen();
    register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for(int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
}

public class TianHeCitizen extends Citizen {

public TianHeCitizen(Policeman pol) {
    setPolicemen();
    register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for (int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
}
</code></pre><p>###ConcreteObserver </p>
<pre><code>public class HuangPuPoliceman implements Policeman {

public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals(&quot;normal&quot;)) {
        System.out.println(&quot;一切正常, 不用出动&quot;);
    }
    if (help.equals(&quot;unnormal&quot;)) {
        System.out.println(&quot;有犯罪行为, 黄埔警察出动!&quot;);
    }
}
}
public class TianHePoliceman implements Policeman {

public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals(&quot;normal&quot;)) {
        System.out.println(&quot;一切正常, 不用出动&quot;);
    }
    if (help.equals(&quot;unnormal&quot;)) {
        System.out.println(&quot;有犯罪行为, 天河警察出动!&quot;);
    }
}
}
</code></pre><p>###Test </p>
<pre><code>public class Test{

public static void main(String[] args) {
    Policeman thPol = new TianHePoliceman();
    Policeman hpPol = new HuangPuPoliceman();

    Citizen citizen = new HuangPuCitizen(hpPol);
    citizen.sendMessage(&quot;unnormal&quot;);
    citizen.sendMessage(&quot;normal&quot;);

    System.out.println(&quot;===========&quot;);

    citizen = new TianHeCitizen(thPol);
    citizen.sendMessage(&quot;normal&quot;);
    citizen.sendMessage(&quot;unnormal&quot;);
}
}
</code></pre><p>###result </p>
<pre><code>有犯罪行为, 黄埔警察出动!
一切正常, 不用出动
===========
一切正常, 不用出动
有犯罪行为, 天河警察出动!
</code></pre><p>#TravelBc&amp;Observer</p>
<p><strong>连蒙带编，终于写到这，还好我没放弃！！！</strong></p>
<p>##需求</p>
<p>Travelbc相关部分的需求比较简单，当Travelbc接收到支付成功的消息后，会根据具体业务进行预约订单与预约记录的创建，由于预约订单与记录的创建或修改会导致一些诸如定时任务的创建，订单与预约状态的修改，Toc时间设置等等。完全符合Observer模式适用范围，因为Observer模式是实现这此逻辑的不二之选。</p>
<p>##结构</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/11bb8785681aaf33dd2282674e66ef6c7c5b1056.png" alt=""></p>
<p>##流程</p>
<p>整个流程就很清晰了，Subject会接收到支付成功的消息，接着会调用ChangeManager中的相应方法，ChangeManager中通过spring的bean注入方式注入Obersver列表。这些的obersver大多叫作XXXProcessor,ChangeManager就会负责Processor与管理工作与迭代通知操作。</p>
<p>#总结</p>
<p>Travelbc&amp;Observer部分分析的内容比较少，主要是因为Observer的内容介绍的比较多。如果能理解Observer模式应该就很容易理解Travelbc中的这块内容。但事实是我其实也没有深刻理解Observer模式，或者我可能会用他，但我不会扩展或升级他。<br>上面的内容有很多来自于书籍或网上教程，虽然我自己个人理解的内容相对少一点，但是我再次强调我现阶段写文章的目的是：</p>
<p><strong>作为自己学习的笔记与总结</strong></p>
<p><strong>方便大家在网上搜索出来快速了解</strong></p>
<p>仅此而已</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/icon.png"
               alt="欣明果果" />
          <p class="site-author-name" itemprop="name">欣明果果</p>
          <p class="site-description motion-element" itemprop="description">突然发现自己的偶像是灰太狼。。。。。。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">欣明果果</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
